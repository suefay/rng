// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @notice Interface for consuming contracts which request randomness generated by VRF.
 */
abstract contract VRFConsumerBase {
  address immutable private vrfCoordinator;

  /**
   * @param _vrfCoordinator Address of the VRF coordinator contract
   */
  constructor(address _vrfCoordinator) {
    vrfCoordinator = _vrfCoordinator;
  }
 
  /**
   * @notice fulfillRandomness handles the VRF response. Your contract must
   * @notice implement it. See "SECURITY CONSIDERATIONS" above for important
   * @notice principles to keep in mind when implementing your fulfillRandomness
   * @notice method.
   *
   * @dev VRFConsumerBase expects its subcontracts to have a method with this
   * @dev signature, and will call it once it has verified the proof
   * @dev associated with the randomness. (It is triggered via a call to
   * @dev rawFulfillRandomness, below.)
   *
   * @param requestId The Id initially returned by requestRandomness
   * @param randomness the VRF output
   */
  function fulfillRandomness(uint256 requestId, uint256 randomness) internal virtual;

  // rawFulfillRandomness is called by VRFCoordinator when it receives a valid VRF
  // proof. rawFulfillRandomness then calls fulfillRandomness, after validating
  // the origin of the call
  function rawFulfillRandomness(uint256 requestId, uint256 randomness) external {
    require(msg.sender == vrfCoordinator, "VRFConsumerBase: only VRFCoordinator can fulfill");
    fulfillRandomness(requestId, randomness);
  }
}
